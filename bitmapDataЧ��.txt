
flash的优化效率挺高的 貌似直接把所有的bitmap放在同一个sprite里 直接移动sprite 好像效率也还行 这种方法使用起来相当easy 我曾经尝试过各种直接操作bitmap的方法 貌似效率都还不如移动整个sprite来得高。
flash在界面上 移动的层越少 效率就越高 也就是说 5个bitmap用for移动 比5个bitmap放在一个sprite中直接移动sprite效率低得多

大家可以尝试把4方向判断缩减为单方向，会发现消耗比bmp下降。

是的~ 所有的bitmap放在一个script中 直接移动script 速度最优化
所有的算法都必须是能控制底层 as3的显示api已经封装的很好了 优化的很强了
有些时候有些效果连 c++ openGL都做不到~


我尝试把1000个 1000x1000的bitmap分布排列在一个script中 只要一次移动script里面的bitmap的个数对运行的速度并没有本质区别
当时我就觉得，在信任adobe显示框架优化的同时 也失去了研究卡马克卷轴的机会 呵呵~~~

把多个bitmap放入sprite，然后给sprite开位图缓存，效率和滚动一张大图是一样的。这点没有问题
而现在我所研究的是如何再进一步提高效率

在单向缓冲中，已经完胜了x,y平移，但是这样意义并不大。现在的问题是如何将其拓展到4方向并保持这个效率


又测试了一下，bitmap单纯x,y最快，把bitmap放到sprite里，sprite移动次之，scroll和copypixel再之，单纯copypixel最慢


scroll本身是一个耗费计算的操作。它其实和unlock的效果是差不多的。也就是说scroll相当于一个全屏刷新，在实际的应用中我发现对于非粒子的物体，类似背景这样的大物体不使用卷轴算法直接用Bitmap要快很多。多层背景的scoll+copyPixels实际的消耗是不小的。  并且在带有架构的实际卷轴应用里面，对于大量粒子的重绘有两周处理方式。一种是所谓自动选择的，根据当前timer构成的线程调度中如果所需要绘制的粒子总像素大于屏幕的总像素采用全屏绘制，否则就区域绘制，这种方式在对于不滚屏时候有相当的效果，然而如果加上滚屏，实际上强制指定全屏重绘的开销更小.

这里有一个反向的思考我想听听大家怎么看。也就是在实际的结果上，往往是我们认为的最笨的最没有技术含量的做法，往往是可以得到最好结果的方式，就比如全屏渲染听起来是很蠢的做法，但是有的时候它就是比区域渲染还快(比如大量的粒子)。

个人按照地图分块的方式构造了种地图滚动法，还未实现，
      具体1将地图分块，多少由地图大小决定，然后用坐标分出序列存入数组，
          2 显示区缓冲区，同样分块块大小与地图块等同，共分为6块，用于显示地图到场景上，每次场景中出现块数不超过6块，
          3游戏开始，首先读入第一部分的六块地图，随主角移动移动地图块，
          4当缓冲区的对应部分地图块不显示在场景上，则开始重新读地图数组中的地图块，


说实话，我记得卡马克当初是希望在计算机上实现一个马里奥游戏，发觉全屏所有像素在滚屏时都会更新，所以效率很低，于是他通过欺骗程序将一些没有变化的像素跳过重新渲染所以达到了提高效果。这种方法的前提就是类似马里奥那种屏幕上只有小部分像素更新的游戏，另一方面是可以控制渲染，但是在楼主的方法中我完全没看出哪里有涉及到这方面优化的，因为所有的像素还是被重新渲染的，所以跟卡马克卷轴风马牛不相及。


   此种算法应该是应用在位图引擎中的,对游戏来说,用SP和MC性能是无法保障的,特别是元件多时.我试过new1000个空的Sprite,啥也不做,鼠标一动,CPU就上去了.而位图引擎能确保显示时都在一张位图上.通过对位图的操作实现一个虚拟显示容器. 我试验的结果是,这种算法要比全屏刷新要快一些,但也不明显.主要在地图不移动,而场景中的元素移动时,比直接全屏刷新要优化得多.


http://www.8bitrocket.com/2009/05/03/tutorial-clearing-a-blit-canvas-by-erasing-only-the-portions-that-have-changed-using-damage-maps-or-a-dirty-rect/
